{"mappings":"MAAA,MAAMA,EAAsB,CAC1BC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,IAGE,SAASC,EAAgBC,GAC9B,MAAMC,EAAQD,EACXE,MAAM,KACNC,QAAQC,GAAkB,KAATA,IACjBC,KAAKC,IACJ,MAAMC,EAAOD,EAAW,GAClBE,EAAOF,EAAW,GAExB,IAAIG,EAAUhB,EAAoBc,IAASG,SAASH,GAIpD,OAFAE,GAAW,EAEJ,C,KACLD,E,KACAD,E,QACAE,E,WACAH,MAIN,OADAL,EAAMU,MAAK,CAACC,EAAGC,IAAMA,EAAEJ,QAAUG,EAAEH,UAC5BR,EC5BF,MAAMa,EAAQ,CACnBC,UAAW,YACXC,KAAM,OACNC,SAAU,WACVC,gBAAiB,kBACjBC,SAAU,WACVC,MAAO,QACPC,WAAY,aACZC,eAAgB,iBAChBC,eAAgB,kBAGLC,EAAe,CAC1B,CAACV,EAAMC,WAAY,EACnB,CAACD,EAAME,MAAO,EACd,CAACF,EAAMG,UAAW,EAClB,CAACH,EAAMI,iBAAkB,EACzB,CAACJ,EAAMK,UAAW,EAClB,CAACL,EAAMM,OAAQ,EACf,CAACN,EAAMO,YAAa,EACpB,CAACP,EAAMQ,gBAAiB,EACxB,CAACR,EAAMS,gBAAiB,GAGbE,EAAkB,CAC7B3B,EAAG,GACHD,EAAG,GACHD,EAAG,GACHD,EAAG,EACHD,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,GAGQgC,EAAmB,CAC9B,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MC1FK,SAASC,EAAcC,GAC5B,OAGK,SACLC,EACAC,EACAC,GAAW,GAENA,IACHF,EAAWA,EAASl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","sources":["util.js","constants.js","handUtils.js","calculateHands.js","playhand.js","index.js"],"sourcesContent":["const nonNumericRankToNum = {\n  T: 10,\n  J: 11,\n  Q: 12,\n  K: 13,\n  A: 14,\n};\n\nexport function cardStringToObj(cardsString) {\n  const cards = cardsString\n    .split('?')\n    .filter((card) => card !== '')\n    .map((cardString) => {\n      const rank = cardString[0];\n      const suit = cardString[1];\n\n      let ranknum = nonNumericRankToNum[rank] || parseInt(rank);\n      // Rank number should go 0 - 12\n      ranknum -= 2;\n\n      return {\n        suit,\n        rank,\n        ranknum,\n        cardString,\n      };\n    });\n  cards.sort((a, b) => b.ranknum - a.ranknum);\n  return cards;\n}\n","export const HANDS = {\n  HIGH_CARD: 'HIGH CARD',\n  PAIR: 'PAIR',\n  TWO_PAIR: 'TWO PAIR',\n  THREE_OF_A_KIND: 'THREE OF A KIND',\n  STRAIGHT: 'STRAIGHT',\n  FLUSH: 'FLUSH',\n  FULL_HOUSE: 'FULL HOUSE',\n  FOUR_OF_A_KIND: 'FOUR OF A KIND',\n  STRAIGHT_FLUSH: 'STRAIGHT FLUSH',\n};\n\nexport const RANKED_HANDS = {\n  [HANDS.HIGH_CARD]: 1,\n  [HANDS.PAIR]: 2,\n  [HANDS.TWO_PAIR]: 3,\n  [HANDS.THREE_OF_A_KIND]: 4,\n  [HANDS.STRAIGHT]: 5,\n  [HANDS.FLUSH]: 6,\n  [HANDS.FULL_HOUSE]: 7,\n  [HANDS.FOUR_OF_A_KIND]: 8,\n  [HANDS.STRAIGHT_FLUSH]: 9,\n};\n\nexport const RANK_TO_NUMRANK = {\n  A: 12,\n  K: 11,\n  Q: 10,\n  J: 9,\n  T: 8,\n  9: 7,\n  8: 6,\n  7: 5,\n  6: 4,\n  5: 3,\n  4: 2,\n  3: 1,\n  2: 0,\n};\n\nexport const ALL_CARD_STRINGS = [\n  '2D',\n  '2C',\n  '2H',\n  '2S',\n  '3D',\n  '3C',\n  '3H',\n  '3S',\n  '4D',\n  '4C',\n  '4H',\n  '4S',\n  '5D',\n  '5C',\n  '5H',\n  '5S',\n  '6D',\n  '6C',\n  '6H',\n  '6S',\n  '7D',\n  '7C',\n  '7H',\n  '7S',\n  '8D',\n  '8C',\n  '8H',\n  '8S',\n  '9D',\n  '9C',\n  '9H',\n  '9S',\n  'TD',\n  'TC',\n  'TH',\n  'TS',\n  'JD',\n  'JC',\n  'JH',\n  'JS',\n  'QD',\n  'QC',\n  'QH',\n  'QS',\n  'KD',\n  'KC',\n  'KH',\n  'KS',\n  'AD',\n  'AC',\n  'AH',\n  'AS',\n];\n","import { HANDS, RANK_TO_NUMRANK } from './constants';\n\nexport function checkStraight(allCardsSorted) {\n  return checkStraightOrDrawOfLength(allCardsSorted, 5, true);\n}\n\nexport function checkStraightOrDrawOfLength(\n  allCards,\n  lengthOfDraw,\n  isSorted = false\n) {\n  if (!isSorted) {\n    allCards = allCards.sort((a, b) => b.ranknum - a.ranknum);\n  }\n  const sortedRanks = allCards.map((c) => c.rank);\n  const uniqueRanksInOrder = new Set(sortedRanks);\n  const rankIterator = uniqueRanksInOrder.values();\n  let previousRank = rankIterator.next().value;\n  let startingRank = previousRank;\n  let lengthSoFar = 1;\n  for (const rank of rankIterator) {\n    if (RANK_TO_NUMRANK[previousRank] - RANK_TO_NUMRANK[rank] === 1) {\n      lengthSoFar++;\n      if (lengthSoFar === lengthOfDraw) {\n        return startingRank;\n      }\n    } else {\n      startingRank = rank;\n      lengthSoFar = 1;\n    }\n    previousRank = rank;\n  }\n  // if there's an ace & we're one card away from a straight & the last rank we looked at was a 2, it's a straight\n  if (\n    uniqueRanksInOrder.has('A') &&\n    lengthOfDraw - 1 === lengthSoFar &&\n    previousRank === '2'\n  ) {\n    return startingRank;\n  }\n}\n\nexport function myPokerHand(handCards, boardCards) {\n  const rankToCount = new Map();\n  const suitToCount = new Map();\n  const allCards = handCards.concat(boardCards);\n  allCards.sort((a, b) => b.ranknum - a.ranknum);\n  allCards.forEach((card) => {\n    rankToCount.set(card.rank, (rankToCount.get(card.rank) || 0) + 1);\n    suitToCount.set(card.suit, (suitToCount.get(card.suit) || 0) + 1);\n  });\n\n  let highestRankAndCount = { count: 0 };\n  let secondHighestRankAndCount = { count: 0 };\n  rankToCount.forEach((count, rank) => {\n    // maps preserve insertion order, so we know higher ranks always come first\n    if (count > highestRankAndCount.count) {\n      secondHighestRankAndCount = highestRankAndCount;\n      highestRankAndCount = { rank, count };\n    } else if (count > secondHighestRankAndCount.count) {\n      secondHighestRankAndCount = { rank, count };\n    }\n  });\n\n  // Check straight flush\n  let flushRanks;\n  let straightFlushTopRank;\n  suitToCount.forEach((count, suit) => {\n    if (count >= 5) {\n      const cardsOfSuit = allCards.filter((card) => card.suit === suit);\n      flushRanks = cardsOfSuit.map((card) => card.rank).slice(0, 5);\n      straightFlushTopRank = checkStraight(cardsOfSuit);\n    }\n  });\n\n  if (straightFlushTopRank) {\n    return {\n      hand: HANDS.STRAIGHT_FLUSH,\n      handRanks: [straightFlushTopRank],\n      kickers: [],\n    };\n  }\n\n  // Check 4 of a kind\n  if (highestRankAndCount.count === 4) {\n    const fourOfAKindRank = highestRankAndCount.rank;\n    const cardsMinusFourOfAKind = allCards.filter(\n      (card) => card.rank != fourOfAKindRank\n    );\n\n    return {\n      hand: HANDS.FOUR_OF_A_KIND,\n      handRanks: [fourOfAKindRank],\n      kickers: getTopNRanks(cardsMinusFourOfAKind, 1),\n    };\n  }\n\n  // Check full house\n  if (highestRankAndCount.count === 3 && secondHighestRankAndCount.count >= 2) {\n    const tripRank = highestRankAndCount.rank;\n    const pairRank = secondHighestRankAndCount.rank;\n\n    return {\n      hand: HANDS.FULL_HOUSE,\n      handRanks: [tripRank, pairRank],\n      kickers: [],\n    };\n  }\n\n  // Check flush\n  if (flushRanks) {\n    return {\n      hand: HANDS.FLUSH,\n      handRanks: flushRanks,\n      kickers: [],\n    };\n  }\n\n  // Check straight\n  const topRankInStraight = checkStraight(allCards);\n  if (topRankInStraight) {\n    return {\n      hand: HANDS.STRAIGHT,\n      handRanks: [topRankInStraight],\n      kickers: [],\n    };\n  }\n\n  // Check 3 of a kind\n  if (highestRankAndCount.count === 3) {\n    const tripRank = highestRankAndCount.rank;\n    var cardsMinusTrips = allCards.filter((card) => card.rank != tripRank);\n\n    return {\n      hand: HANDS.THREE_OF_A_KIND,\n      handRanks: [tripRank],\n      kickers: getTopNRanks(cardsMinusTrips, 2),\n    };\n  }\n\n  // Check 2 pair\n  if (\n    highestRankAndCount.count === 2 &&\n    secondHighestRankAndCount.count === 2\n  ) {\n    const pairRanks = [\n      highestRankAndCount.rank,\n      secondHighestRankAndCount.rank,\n    ];\n\n    var cardsMinusPairs = allCards.filter(\n      (card) => !pairRanks.includes(card.rank)\n    );\n\n    return {\n      hand: HANDS.TWO_PAIR,\n      handRanks: pairRanks,\n      kickers: getTopNRanks(cardsMinusPairs, 1),\n    };\n  }\n\n  // Check pair\n  if (highestRankAndCount.count === 2) {\n    const pairRank = highestRankAndCount.rank;\n    var cardsMinusPair = allCards.filter((card) => card.rank != pairRank);\n\n    return {\n      hand: HANDS.PAIR,\n      handRanks: [pairRank],\n      kickers: getTopNRanks(cardsMinusPair, 3),\n    };\n  }\n\n  return {\n    hand: HANDS.HIGH_CARD,\n    handRanks: [],\n    kickers: getTopNRanks(allCards, 5),\n  };\n}\n\n// We're not sorting because we're assuming the cards are already sorted (beginning of myPokerHand)\nexport function getTopNRanks(cards, n) {\n  return cards.map((card) => card.rank).slice(0, n);\n}\n","import { ALL_CARD_STRINGS, RANK_TO_NUMRANK, RANKED_HANDS } from './constants';\nimport { cardStringToObj } from './util';\nimport { myPokerHand } from './handUtils';\n\nfunction compareHands(hand1Results, hand2Results) {\n  var diff = RANKED_HANDS[hand1Results.hand] - RANKED_HANDS[hand2Results.hand];\n\n  if (diff > 0) {\n    return 'win';\n  } else if (diff < 0) {\n    return 'lose';\n  }\n\n  for (const [i, handRank] of hand1Results.handRanks.entries()) {\n    diff =\n      RANK_TO_NUMRANK[handRank] - RANK_TO_NUMRANK[hand2Results.handRanks[i]];\n    if (diff > 0) {\n      return 'win';\n    } else if (diff < 0) {\n      return 'lose';\n    }\n  }\n\n  for (const [i, kicker] of hand1Results.kickers.entries()) {\n    diff = RANK_TO_NUMRANK[kicker] - RANK_TO_NUMRANK[hand2Results.kickers[i]];\n    if (diff > 0) {\n      return 'win';\n    } else if (diff < 0) {\n      return 'lose';\n    }\n  }\n\n  return 'draw';\n}\n\nexport function calculateWinAgainstPercent(hand, board) {\n  const exceptCards = new Set([\n    ...hand.map((handCard) => handCard.cardString),\n    ...board.map((boardCard) => boardCard.cardString),\n  ]);\n  if (board.length === 5) {\n    return winAgainstPercentFullBoard(hand, board, exceptCards);\n  } else if (board.length === 4) {\n    const allOtherCards = ALL_CARD_STRINGS.filter(\n      (card) => !exceptCards.has(card)\n    );\n    const percentTotal = allOtherCards.reduce((acc, card) => {\n      const boardWithCard = [...board, ...cardStringToObj(card)];\n      exceptCards.add(card);\n      acc += winAgainstPercentFullBoard(hand, boardWithCard, exceptCards);\n      exceptCards.delete(card);\n      return acc;\n    }, 0);\n    return percentTotal / allOtherCards.length;\n  } else if (board.length === 3) {\n    const allOtherCards = ALL_CARD_STRINGS.filter(\n      (card) => !exceptCards.has(card)\n    );\n    let percentTotal = 0;\n    for (let i = 0; i < allOtherCards.length; i++) {\n      exceptCards.add(allOtherCards[i]);\n      for (let j = i + 1; j < allOtherCards.length; j++) {\n        exceptCards.add(allOtherCards[j]);\n        const boardWithCards = [\n          ...board,\n          ...cardStringToObj(allOtherCards[i]),\n          ...cardStringToObj(allOtherCards[j]),\n        ];\n        percentTotal += winAgainstPercentFullBoard(\n          hand,\n          boardWithCards,\n          exceptCards\n        );\n        exceptCards.delete(allOtherCards[j]);\n      }\n      exceptCards.delete(allOtherCards[i]);\n    }\n    return (\n      percentTotal / ((allOtherCards.length * (allOtherCards.length - 1)) / 2)\n    );\n  }\n}\n\nfunction winAgainstPercentFullBoard(hand, board, exceptCards) {\n  let wins = 0;\n  let losses = 0;\n  let draws = 0;\n  const allOtherCards = ALL_CARD_STRINGS.filter(\n    (card) => !exceptCards.has(card)\n  );\n  const myHandResults = myPokerHand(hand, board);\n  for (let i = 0; i < allOtherCards.length; i++) {\n    for (let j = i + 1; j < allOtherCards.length; j++) {\n      const otherHand = cardStringToObj(\n        `${allOtherCards[i]}?${allOtherCards[j]}?`\n      );\n      const otherHandResults = myPokerHand(otherHand, board);\n      const result = compareHands(myHandResults, otherHandResults);\n      if (result === 'win') {\n        wins++;\n      } else if (result === 'lose') {\n        losses++;\n      } else if (result === 'draw') {\n        draws++;\n      }\n    }\n  }\n  return (wins + draws) / (wins + draws + losses);\n}\n","import { cardStringToObj } from './util';\nimport { calculateWinAgainstPercent } from './calculateHands';\n\nlet tauntOpportunity = false; // set to true if I'm in a showdown and someone else is all-in\n\nconst mb = {\n  // constants\n  BIG_BLIND: game.big_blind / 100, // not accounting for someone changing BB mid-game\n  ALL: 'all',\n};\n\nconst preFlopHandsToBetMultipliers = {\n  // hand_ranks: [call_to, raise_to]\n  // call_to and raise_to are multipliers of the big blind\n  AA: [mb.ALL, mb.ALL],\n  72: [0, mb.ALL],\n  KK: [mb.ALL, mb.ALL],\n  QQ: [mb.ALL, mb.ALL],\n  JJ: [mb.ALL, mb.ALL],\n  TT: [mb.ALL, mb.ALL],\n  99: [10, 3],\n  88: [10, 3],\n  AK: [mb.ALL, mb.ALL],\n  AQ: [30, 3],\n  AJ: [30, 3],\n  A5: [3, 1],\n  AT: [8, 3],\n  A9: [1, 1],\n  A8: [1, 1],\n  KQ: [8, 3],\n  KJ: [8, 3],\n  KT: [3, 3],\n  K9: [1, 1],\n  QJ: [3, 1],\n  QT: [3, 1],\n  Q9: [1, 1],\n  Q8: [1, 1],\n  JT: [3, 1],\n  J9: [1, 1],\n  J8: [1, 1],\n  J7: [1, 1],\n  T9: [1, 1],\n  77: [3, 1],\n  66: [3, 1],\n  55: [3, 1],\n  44: [3, 1],\n  33: [3, 1],\n  22: [3, 1],\n};\n\nconst suitedPreFlopHandsToBetMultipliers = {\n  AK: [mb.ALL, mb.ALL],\n  AQ: [mb.ALL, mb.ALL],\n  AJ: [30, 5],\n  AT: [10, 5],\n  A9: [10, 3],\n  A8: [8, 3],\n  A7: [6, 1],\n  A6: [6, 1],\n  A5: [8, 3],\n  A4: [5, 1],\n  A3: [5, 1],\n  A2: [5, 1],\n  KQ: [10, 5],\n  KJ: [10, 5],\n  KT: [8, 3],\n  K9: [6, 3],\n  K8: [1, 3],\n  QJ: [10, 5],\n  QT: [8, 1],\n  Q9: [3, 1],\n  Q8: [3, 1],\n  JT: [10, 3],\n  J9: [3, 1],\n  J8: [3, 1],\n  J7: [3, 1],\n  T9: [6, 3],\n  T8: [1, 1],\n  T7: [1, 1],\n  98: [5, 1],\n  97: [1, 1],\n  87: [5, 1],\n  86: [1, 1],\n  76: [1, 1],\n  75: [1, 1],\n  65: [1, 1],\n  64: [1, 1],\n  54: [1, 1],\n  43: [1, 1],\n  32: [1, 1],\n};\n\nexport async function checkIfTurnAndPlay() {\n  if (\n    !game.action_widget ||\n    !game.players[game.client_perspective].cards.card_str\n  ) {\n    // seems like sometimes action_widget will be truthy but there are no cards... skip\n    return;\n  }\n  await new Promise((resolve) => setTimeout(resolve, 1000)); // attempt to fix stack size mismatch error - unclear if helpful\n  const holeCards = game.players[game.client_perspective].cards.card_str;\n  const boardCards = game.board.card_str;\n  const boardCardsLogMsg = boardCards\n    ? ` and the board shows ${boardCards}.`\n    : '.';\n  console.log(`My hole cards are ${holeCards}${boardCardsLogMsg}`);\n  playHand(holeCards, boardCards);\n}\n\nfunction setDefaultGameOptions() {\n  if (\n    game.game_options_widget.allow_easy_reveal &&\n    !game.game_options_widget.easy_reveal.is_checked()\n  ) {\n    game.game_options_widget.easy_reveal.clicked();\n  }\n  if (\n    game.game_options_widget.bomb_pot_value &&\n    !game.game_options_widget.bomb_pot.is_checked()\n  ) {\n    game.game_options_widget.bomb_pot.clicked();\n  }\n}\n\nfunction checkOrFold() {\n  if (game.action_widget.to_call === 0) {\n    checkOrCall();\n  } else {\n    game.action_widget.execute_fold();\n  }\n}\n\nfunction checkOrCall() {\n  game.action_widget.execute_check_call();\n}\n\nfunction makeBetOfSize(callToLimit, raiseToLimit) {\n  // TODO later on, take in increment size so we can do smaller raises\n  const betInFront = game.action_widget.bet_in_front;\n  const betSizeIfCall = betInFront + game.action_widget.to_call / 100;\n  const betSizeIfAllIn = betInFront + game.action_widget.stack_size;\n  const minBet = game.action_widget.threshold_values.length\n    ? game.action_widget.threshold_values[0]\n    : undefined;\n  console.info(\n    `Raise to limit: ${raiseToLimit}. Min bet: ${minBet}. Call to limit: ${callToLimit}. Bet size if call: ${betSizeIfCall}.`\n  );\n  if (game.action_widget.bet_button || game.action_widget.raise_button) {\n    if (minBet <= raiseToLimit) {\n      console.log(\n        raiseToLimit === betSizeIfAllIn\n          ? 'Going all in.'\n          : `Raising to ${raiseToLimit}.`\n      );\n      game.action_widget.update_slider_by_value(raiseToLimit);\n      game.action_widget.sizing_input.value = raiseToLimit;\n      game.action_widget.execute_bet_raise();\n      return;\n    }\n  }\n  // If we get here, either raising wasn't an option in the game or the min bet was too high for us.\n  if (game.action_widget.all_in && betSizeIfAllIn <= raiseToLimit) {\n    console.log(\"Can't/won't raise; going all in instead.\");\n    game.action_widget.all_in.execute();\n  } else if (game.action_widget.call_button && betSizeIfCall <= callToLimit) {\n    console.log(\"Can't/won't raise; calling instead.\");\n    checkOrCall();\n  } else {\n    console.log('Checking/folding.');\n    checkOrFold();\n  }\n}\n\nfunction makeBetUsingMultipliers(callToMult, raiseToMult) {\n  const betSizeIfAllIn =\n    game.action_widget.stack_size + game.action_widget.bet_in_front;\n  const callToLimit =\n    callToMult === mb.ALL ? betSizeIfAllIn : callToMult * mb.BIG_BLIND;\n  const raiseToLimit =\n    raiseToMult === mb.ALL ? betSizeIfAllIn : raiseToMult * mb.BIG_BLIND;\n  makeBetOfSize(callToLimit, raiseToLimit);\n}\n\nfunction playHand(handString, boardString) {\n  if (game.ruleset_name !== 'NL Texas Holdem') {\n    console.log(\n      `Folding/checking because we aren't playing 'NL Texas Holdem'. The game is ${game.ruleset_name}.`\n    );\n    checkOrFold();\n    return;\n  }\n  try {\n    setDefaultGameOptions();\n  } catch (e) {\n    // we don't really care\n  }\n\n  if (boardString === '') {\n    preflop(handString);\n  } else {\n    postflop(handString, boardString, game.n_players_in_hand);\n  }\n}\n\nfunction preflop(cardsString) {\n  const [card1, card2] = cardStringToObj(cardsString);\n  const handRanksString = card1.rank + card2.rank;\n\n  if (card1.suit === card2.suit) {\n    const suitedBetMultipliers =\n      suitedPreFlopHandsToBetMultipliers[handRanksString];\n    if (suitedBetMultipliers) {\n      console.log(\n        'Preflop cards are suited, and match one of the suited starting hands'\n      );\n      const [callToMult, raiseToMult] = suitedBetMultipliers;\n      preflopBettingRandomization(callToMult, raiseToMult);\n      return;\n    }\n  }\n\n  const betMultipliers = preFlopHandsToBetMultipliers[handRanksString];\n  if (!betMultipliers) {\n    if (Math.random() > 0.9) {\n      // 10% of the time we will randomly limp in\n      console.log(\n        \"Even though this isn't a hand we usually play, randomly limping in if it's cheap.\"\n      );\n      makeBetUsingMultipliers(3, 1);\n      return;\n    }\n\n    console.log('Checking or folding.');\n    checkOrFold();\n    return;\n  }\n\n  const [callToMult, raiseToMult] = betMultipliers;\n  preflopBettingRandomization(callToMult, raiseToMult);\n}\n\nfunction preflopBettingRandomization(callToMult, raiseToMult) {\n  if (raiseToMult === mb.ALL) {\n    rand = Math.random();\n    if (rand < 0.2) {\n      makeBetUsingMultipliers(callToMult, 3);\n    } else if (rand < 0.4) {\n      makeBetUsingMultipliers(callToMult, 5);\n    } else if (rand < 0.6) {\n      makeBetUsingMultipliers(callToMult, 10);\n    } else {\n      makeBetUsingMultipliers(callToMult, mb.ALL);\n    }\n  } else {\n    makeBetUsingMultipliers(callToMult, raiseToMult);\n  }\n}\n\nfunction postflop(handString, boardString, playersInHand) {\n  const holeCards = cardStringToObj(handString);\n  const boardCards = cardStringToObj(boardString);\n\n  // TODO let's add some light memoization to remember just the last winAgainstPercent for same hand & board cards\n  const winAgainstPercent = calculateWinAgainstPercent(holeCards, boardCards);\n  console.log(\n    `Chances of winning against a random hand: ${winAgainstPercent}.`\n  );\n  console.log(`Number of players in hand: ${playersInHand}.`);\n\n  // winAgainstPercent thresholds for betting are based on the number of players in the hand\n  bigBetThreshold = 0.75;\n  smallBetThreshold = 0.6;\n  if (playersInHand == 2) {\n    bigBetThreshold = 0.6;\n    smallBetThreshold = 0.4;\n  } else if ((playersInHand = 3)) {\n    bigBetThreshold = 0.65;\n    smallBetThreshold = 0.5;\n  }\n\n  const shouldBluffRandomly = Math.random() > 0.95;\n  console.log(\n    `Small bet threshold: ${smallBetThreshold}, Big bet threshold: ${bigBetThreshold}, random bluff: ${shouldBluffRandomly}`\n  );\n\n  const totalPotSize = game.action_widget.pot_size;\n  if (winAgainstPercent > 0.9) {\n    const betSizeIfAllIn =\n      game.action_widget.bet_in_front + game.action_widget.stack_size;\n    // 1/3 of the time, if it's not the last round, we set raiseTo to 0 so that we check if possible\n    // TODO let's do this if there's 5 board cards AND we're last to act\n    const shouldCheck = Math.random() * 3 > 2 && boardCards.length < 5;\n    const raiseTo = shouldCheck ? 0 : Math.random() * betSizeIfAllIn;\n    return makeBetOfSize(betSizeIfAllIn, raiseTo);\n  } else if (winAgainstPercent > bigBetThreshold) {\n    const scaledWinAgainstPercent = (winAgainstPercent - 0.65) / (0.9 - 0.65);\n    return makeBetOfSize(\n      Math.max(3 * mb.BIG_BLIND, totalPotSize * 2 * scaledWinAgainstPercent),\n      totalPotSize * scaledWinAgainstPercent\n    );\n  } else if (winAgainstPercent > smallBetThreshold) {\n    return makeBetOfSize(Math.max(3 * mb.BIG_BLIND, totalPotSize / 10), 0);\n  } else if (shouldBluffRandomly) {\n    console.log(\"I'm just bluffing!\");\n    return makeBetUsingMultipliers(0, mb.ALL);\n  }\n  console.log('Checking or folding.');\n  checkOrFold();\n}\n\nexport function handleShowdown() {\n  const seat = game.client_perspective;\n  if (\n    game.n_players_in_hand > 1 &&\n    game.players[seat].is_sitting_in &&\n    !game.players[seat].is_folded\n  ) {\n    console.log('SHOWDOWN WITH ME IN IT');\n    console.log('# players in showdown:', game.n_players_in_hand);\n    tauntOpportunity = Object.entries(game.players).some(\n      ([i, player]) =>\n        player.is_sitting_in &&\n        !player.is_folded &&\n        player.chips === 0 &&\n        i !== seat + ''\n    );\n    console.log('tauntOpportunity', tauntOpportunity);\n  }\n}\n\nexport function handlePotDistribution(potData) {\n  const seat = game.client_perspective;\n  if (\n    tauntOpportunity &&\n    potData.winners[seat] &&\n    Object.keys(potData.winners).length === 1\n  ) {\n    // TODO will taunt before animations finish. eventually, add a delay or wait for some event\n    // indicating animations are done\n    console.log('Taunting because I knocked someone out!');\n    socket.emit('taunt', {\n      taunt: 16,\n      id: game.table_id,\n      group_id: game.group_id,\n    });\n  }\n  tauntOpportunity = false;\n}\n","import {\n  checkIfTurnAndPlay,\n  handleShowdown,\n  handlePotDistribution,\n} from './playhand';\n\nsetInterval(play, 2500);\nsocket.on('is in showdown', handleShowdown);\nsocket.on('distributing pot', handlePotDistribution);\n\nlet isPlayingNow = false;\nasync function play() {\n  try {\n    if (!isPlayingNow) {\n      isPlayingNow = true;\n      await checkIfTurnAndPlay();\n    }\n  } finally {\n    await new Promise((resolve) => setTimeout(resolve, 1000)); // small pause so we don't enter this loop back to back\n    isPlayingNow = false;\n  }\n}\n"],"names":["$0df1a61bc49d2233$var$nonNumericRankToNum","T","J","Q","K","A","$0df1a61bc49d2233$export$1c585bc21eb51405","cardsString","cards","split","filter","card","map","cardString","rank","suit","ranknum","parseInt","sort","a","b","$4bc93b426d7a2d10$export$c0e98576cfcf6795","HIGH_CARD","PAIR","TWO_PAIR","THREE_OF_A_KIND","STRAIGHT","FLUSH","FULL_HOUSE","FOUR_OF_A_KIND","STRAIGHT_FLUSH","$4bc93b426d7a2d10$export$90a5fa66fb680598","$4bc93b426d7a2d10$export$25d516e80805b3c6","$4bc93b426d7a2d10$export$7e12c4d272e606e9","$4be18b68299772f5$export$ee7ce675b1c1a112","allCardsSorted","allCards","lengthOfDraw","isSorted","sortedRanks","c","uniqueRanksInOrder","Set","rankIterator","values","previousRank","next","value","startingRank","lengthSoFar","has","$4be18b68299772f5$export$50fb8bc86304c405","$4be18b68299772f5$export$d23da08cb65660ef","handCards","boardCards","rankToCount","Map","suitToCount","concat","forEach","set","get","flushRanks","straightFlushTopRank","highestRankAndCount","count","secondHighestRankAndCount","cardsOfSuit","slice","hand","handRanks","kickers","fourOfAKindRank","cardsMinusFourOfAKind","$4be18b68299772f5$export$737596005815f338","tripRank","pairRank","topRankInStraight","cardsMinusTrips","pairRanks","cardsMinusPairs","includes","cardsMinusPair","n","$f7e52e2dd2b44b58$var$compareHands","hand1Results","hand2Results","diff","i","handRank","entries","i1","kicker","$f7e52e2dd2b44b58$export$51283a888492c93b","board","exceptCards","handCard","boardCard","length","$f7e52e2dd2b44b58$var$winAgainstPercentFullBoard","allOtherCards","reduce","acc","boardWithCard","add","delete","percentTotal","j","boardWithCards","wins","losses","draws","myHandResults","result","$f86c89a0cb56440a$var$tauntOpportunity","$f86c89a0cb56440a$var$mb","game","big_blind","$f86c89a0cb56440a$var$preFlopHandsToBetMultipliers","AA","KK","QQ","JJ","TT","AK","AQ","AJ","A5","AT","A9","A8","KQ","KJ","KT","K9","QJ","QT","Q9","Q8","JT","J9","J8","J7","T9","$f86c89a0cb56440a$var$suitedPreFlopHandsToBetMultipliers","A7","A6","A4","A3","A2","K8","T8","T7","async","$f86c89a0cb56440a$export$fd3b4a839fa72ae8","action_widget","players","client_perspective","card_str","Promise","resolve","setTimeout","holeCards","boardCardsLogMsg","console","log","handString","boardString","ruleset_name","$f86c89a0cb56440a$var$checkOrFold","game_options_widget","allow_easy_reveal","easy_reveal","is_checked","clicked","bomb_pot_value","bomb_pot","$f86c89a0cb56440a$var$setDefaultGameOptions","e","card1","card2","handRanksString","suitedBetMultipliers","callToMult","raiseToMult","$f86c89a0cb56440a$var$preflopBettingRandomization","betMultipliers","Math","random","$f86c89a0cb56440a$var$makeBetUsingMultipliers","$f86c89a0cb56440a$var$preflop","playersInHand","winAgainstPercent","bigBetThreshold","smallBetThreshold","shouldBluffRandomly","totalPotSize","pot_size","betSizeIfAllIn","bet_in_front","stack_size","$f86c89a0cb56440a$var$makeBetOfSize","scaledWinAgainstPercent","max","$f86c89a0cb56440a$var$postflop","n_players_in_hand","$f86c89a0cb56440a$var$playHand","to_call","$f86c89a0cb56440a$var$checkOrCall","execute_fold","execute_check_call","callToLimit","raiseToLimit","betInFront","betSizeIfCall","minBet","threshold_values","undefined","info","bet_button","raise_button","update_slider_by_value","sizing_input","execute_bet_raise","all_in","execute","call_button","rand","setInterval","$d1ede43de03c5b3d$var$isPlayingNow","socket","on","seat","is_sitting_in","is_folded","Object","some","player","chips","potData","winners","keys","emit","taunt","id","table_id","group_id"],"version":3,"file":"index.js.map"}